<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Central de Treinamento de Hacks</title>
    <style>
        /* Estilos Globais e Estética */
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Press+Start+2P&display=swap');

        :root {
            --primary-color: #4CAF50;
            --dark-bg: #0D0D0D;
            --medium-bg: #121212;
            --light-text: #E0E0E0;
            --medium-text: #BDBDBD;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--light-text);
            font-family: 'Roboto', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px 0;
        }

        /* Estrutura Geral e Telas */
        .screen { display: none; width: 100%; }
        .screen.active { display: block; }
        .game-container { background-color: var(--medium-bg); border: 1px solid #222; border-radius: 10px; padding: 30px; width: 90%; max-width: 600px; text-align: center; box-shadow: 0 0 20px rgba(76, 175, 80, 0.1); }
        h1, h2, h3 { color: var(--primary-color); text-transform: uppercase; letter-spacing: 2px; margin-top: 0; }
        p { color: var(--medium-text); line-height: 1.6; font-size: 16px; }
        .btn { background-color: var(--primary-color); color: #ffffff; border: none; padding: 12px 30px; font-size: 18px; border-radius: 5px; cursor: pointer; margin-top: 20px; transition: background-color 0.3s, transform 0.2s; text-transform: uppercase; font-weight: bold; }
        .btn:hover { background-color: #5cdb61; transform: translateY(-2px); }
        .btn-back { background-color: #555; font-size: 14px; padding: 8px 20px; }
        .btn-back:hover { background-color: #777; }
        #menu-selection { display: flex; flex-direction: column; gap: 20px; margin-top: 20px; }
        .game-card { background-color: #1a1a1a; border: 1px solid #333; padding: 20px; border-radius: 8px; cursor: pointer; transition: border-color 0.3s, background-color 0.3s; }
        .game-card:hover { border-color: var(--primary-color); background-color: #222; }
        .game-card h3 { margin-top: 0; margin-bottom: 10px; }
        .game-card p { margin-bottom: 0; font-size: 14px; }
        
        /* JOGO 1: MEMÓRIA DE CORES */
        .mem-game-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; font-size: 18px; font-weight: bold; color: var(--primary-color); }
        .mem-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 10px; margin-bottom: 20px; height: 250px; align-content: center; }
        .mem-dot { width: 30px; height: 30px; border-radius: 50%; margin: auto; }
        .mem-question-area { min-height: 270px; display: flex; flex-direction: column; justify-content: center; }
        .mem-question-text { font-size: 22px; margin-bottom: 25px; }
        .mem-options-container { display: flex; justify-content: center; gap: 15px; }
        .mem-option-btn { background-color: #2a2a2a; border: 1px solid var(--primary-color); color: #fff; padding: 12px 25px; font-size: 18px; border-radius: 5px; cursor: pointer; transition: background-color 0.3s; }
        .mem-option-btn:hover:not(:disabled) { background-color: #3c3c3c; }
        .mem-option-btn:disabled { cursor: not-allowed; opacity: 0.7; }

        /* JOGO 2: FURA-FORTE */
        /* MUDANÇA: Ajuste de proporção da tela do jogo */
        #safe-crack-container {
            background-color: #040819;
            border: 10px solid #2a2a2e;
            border-radius: 8px;
            padding: 20px;
            box-sizing: border-box;
            position: relative;
            height: 550px; /* AUMENTADO para mais visão vertical */
            max-width: 400px; /* AJUSTADO para proporção 1:2 */
            margin: 0 auto; /* Adicionado para centralizar */
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
        }

        .sc-title { color: #f3f313; font-size: 18px; text-transform: none; letter-spacing: 0; margin-bottom: 30px; }
        .sc-block-row { position: absolute; top: -50px; left: 0; width: 100%; height: 40px; display: flex; }
        .sc-block-segment { flex-grow: 1; height: 100%; transition: opacity 0.3s, transform 0.3s; }
        .sc-player-drill { position: absolute; bottom: 30px; width: 30px; height: 40px; }
        .sc-game-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; }
        .sc-game-overlay.hidden { display: none; }
        .sc-score { position: absolute; top: 15px; right: 15px; color: #f3f313; font-size: 16px; }
        .speed-selector { margin-bottom: 20px; font-family: 'Roboto', sans-serif; display: flex; flex-direction: column; align-items: center; gap: 8px; }
        .speed-selector label { font-size: 14px; color: var(--medium-text); }
        .speed-selector input { background-color: #333; border: 1px solid #555; color: var(--light-text); border-radius: 4px; padding: 5px 10px; width: 60px; text-align: center; font-size: 16px; }

        @keyframes hit-shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-4px); } 75% { transform: translateX(4px); } }
        .hit-animation { animation: hit-shake 0.3s ease-in-out; }
        .breaking { opacity: 0; transform: scale(0.5); }

    </style>
</head>
<body>

    <div class="game-container">
        <!-- ... (código do menu e jogo da memória inalterado) ... -->
        <div id="main-menu" class="screen active"> <h1>Central de Treinamento</h1> <p>Selecione um minigame para iniciar o treinamento.</p> <div id="menu-selection"> <div class="game-card" data-game="memory-game"> <h3>Hack de Memória</h3> <p>Memorize a quantidade de bolinhas da cor solicitada.</p> </div> <div class="game-card" data-game="safe-crack-game"> <h3>Hack Fura-Forte</h3> <p>Mova a broca para alinhar com a cor correta.</p> </div> </div> </div>
        <div id="memory-game" class="screen"> <h2>Hack de Memória de Cores</h2> <div id="mem-game-screen"> <div class="mem-game-header"> <span id="mem-round-tracker"></span> <span id="mem-timer-display"></span> </div> <div id="mem-grid" class="mem-grid"></div> <div id="mem-question-area" class="mem-question-area" style="display:none;"> <p id="mem-question-text" class="mem-question-text"></p> <div id="mem-options-container" class="mem-options-container"></div> </div> </div> <div id="mem-result-screen" style="display: none;"> <h2>Desafio Concluído!</h2> <p id="mem-result-text" style="font-size: 24px; margin: 20px 0;"></p> <button id="mem-restart-button" class="btn">Tentar Novamente</button> </div> <button class="btn btn-back" onclick="showScreen('main-menu')">Voltar ao Menu</button> </div>

        <!-- TELA 3: JOGO FURA-FORTE -->
        <div id="safe-crack-game" class="screen">
            <div id="safe-crack-container">
                <div id="sc-start-overlay" class="sc-game-overlay">
                    <h3 style="color: #f3f313;">Fura-Forte</h3>
                    <p style="font-family: 'Roboto'; font-size:14px;">Use as setas (← →) para mover a broca.</p>
                    <div class="speed-selector">
                        <label for="sc-speed-input">Velocidade Inicial:</label>
                        <input type="number" id="sc-speed-input" value="2" min="1" max="10" step="0.5">
                    </div>
                    <button id="sc-start-btn" class="btn">Iniciar</button>
                </div>
                <div id="sc-gameover-overlay" class="sc-game-overlay hidden">
                    <h3 style="color: #E53935;">FALHA NO HACK</h3>
                    <p id="sc-final-score" style="font-size: 20px;"></p>
                    <button id="sc-restart-btn" class="btn">Tentar Novamente</button>
                </div>
                <h2 class="sc-title">Match the colors</h2>
                <div id="sc-score" class="sc-score">Pontos: 0</div>
            </div>
            <button class="btn btn-back" onclick="showScreen('main-menu')">Voltar ao Menu</button>
        </div>
    </div>

    <script>
        // --- GERENCIADOR DE TELAS ---
        const screens = document.querySelectorAll('.screen');
        const menuCards = document.querySelectorAll('.game-card');
        function showScreen(screenId) { screens.forEach(s => s.classList.remove('active')); document.getElementById(screenId).classList.add('active'); if (screenId === 'main-menu') { resetMemoryGame(); resetSafeCrackGame(); } }
        menuCards.forEach(card => card.addEventListener('click', () => showScreen(card.getAttribute('data-game'))));
        
        // ===============================================
        // JOGO 1: LÓGICA DO HACK DE MEMÓRIA (inalterado)
        // ===============================================
        const memGameScreen = document.getElementById('mem-game-screen'), memResultScreen = document.getElementById('mem-result-screen'), memGrid = document.getElementById('mem-grid'), memQuestionArea = document.getElementById('mem-question-area'), memQuestionText = document.getElementById('mem-question-text'), memOptionsContainer = document.getElementById('mem-options-container'), memRoundTracker = document.getElementById('mem-round-tracker'), memTimerDisplay = document.getElementById('mem-timer-display'), memResultText = document.getElementById('mem-result-text'), memRestartButton = document.getElementById('mem-restart-button');
        const MEM_CONFIG = { TOTAL_ROUNDS: 5, GRID_SIZE: 35, MEMORIZE_TIME: 5, RESPONSE_TIME: 5, COLORS: [ { name: 'Vermelho', code: '#E53935' }, { name: 'Azul', code: '#1E88E5' }, { name: 'Amarelo', code: '#FDD835' }, { name: 'Verde', code: '#43A047' } ] };
        let memCurrentRound, memScore, memColorCounts, memTimerInterval;
        function startMemoryGame() { memCurrentRound = 1; memScore = 0; memGameScreen.style.display = 'block'; memResultScreen.style.display = 'none'; startMemoryRound(); }
        function startMemoryRound() { memRoundTracker.textContent = `Rodada ${memCurrentRound}/${MEM_CONFIG.TOTAL_ROUNDS}`; memQuestionArea.style.display = 'none'; memOptionsContainer.innerHTML = ''; generateMemoryGrid(); memGrid.style.display = 'grid'; startMemTimer(MEM_CONFIG.MEMORIZE_TIME, showMemoryQuestion); }
        function startMemTimer(duration, callback) { let timeLeft = duration; memTimerDisplay.textContent = `Tempo: ${timeLeft}s`; clearInterval(memTimerInterval); memTimerInterval = setInterval(() => { timeLeft--; memTimerDisplay.textContent = `Tempo: ${timeLeft}s`; if (timeLeft <= 0) { clearInterval(memTimerInterval); callback(); } }, 1000); }
        function generateMemoryGrid() { memGrid.innerHTML = ''; memColorCounts = MEM_CONFIG.COLORS.reduce((acc, color) => ({ ...acc, [color.name]: 0 }), {}); for (let i = 0; i < MEM_CONFIG.GRID_SIZE; i++) { const randomColor = MEM_CONFIG.COLORS[Math.floor(Math.random() * MEM_CONFIG.COLORS.length)]; memColorCounts[randomColor.name]++; const dot = document.createElement('div'); dot.className = 'mem-dot'; dot.style.backgroundColor = randomColor.code; memGrid.appendChild(dot); } }
        function showMemoryQuestion() { memGrid.style.display = 'none'; memQuestionArea.style.display = 'flex'; const targetColor = MEM_CONFIG.COLORS[Math.floor(Math.random() * MEM_CONFIG.COLORS.length)]; const correctAnswer = memColorCounts[targetColor.name]; memQuestionText.innerHTML = `Quantas bolinhas <strong style="color:${targetColor.code};">${targetColor.name}s</strong> havia?`; const options = generateMemOptions(correctAnswer); options.forEach(option => { const button = document.createElement('button'); button.textContent = option; button.className = 'mem-option-btn'; button.onclick = () => checkMemAnswer(option, correctAnswer); memOptionsContainer.appendChild(button); }); startMemTimer(MEM_CONFIG.RESPONSE_TIME, () => checkMemAnswer(-1, correctAnswer)); }
        function generateMemOptions(correctAnswer) { let options = new Set([correctAnswer]); while (options.size < 3) { const offset = Math.floor(Math.random() * 5) - 2; let wrongAnswer = correctAnswer + offset; if (wrongAnswer < 0) wrongAnswer = 0; if (wrongAnswer !== correctAnswer) options.add(wrongAnswer); } return Array.from(options).sort(() => Math.random() - 0.5); }
        function checkMemAnswer(selected, correct) { clearInterval(memTimerInterval); Array.from(memOptionsContainer.children).forEach(btn => { btn.disabled = true; const btnValue = parseInt(btn.textContent); if (btnValue === correct) { btn.style.backgroundColor = '#43A047'; btn.style.borderColor = '#43A047'; } if (btnValue === selected && selected !== correct) { btn.style.backgroundColor = '#E53935'; btn.style.borderColor = '#E53935'; } }); if (selected === correct) memScore++; setTimeout(() => { if (memCurrentRound < MEM_CONFIG.TOTAL_ROUNDS) { memCurrentRound++; startMemoryRound(); } else { showMemResult(); } }, 1800); }
        function showMemResult() { memGameScreen.style.display = 'none'; memResultScreen.style.display = 'block'; memResultText.textContent = `Você acertou ${memScore} de ${MEM_CONFIG.TOTAL_ROUNDS}!`; }
        function resetMemoryGame() { clearInterval(memTimerInterval); memGameScreen.style.display = 'block'; memResultScreen.style.display = 'none'; memQuestionArea.style.display = 'none'; memGrid.style.display = 'block'; memGrid.innerHTML = '<p style="color:#555;">Clique em "Voltar" para escolher um jogo.</p>'; }
        memRestartButton.addEventListener('click', startMemoryGame);
        document.querySelector('.game-card[data-game="memory-game"]').addEventListener('click', startMemoryGame);

        // ===============================================
        // JOGO 2: LÓGICA DO HACK FURA-FORTE (inalterado, pois a mudança foi apenas no CSS)
        // ===============================================
        const scContainer = document.getElementById('safe-crack-container'), scStartOverlay = document.getElementById('sc-start-overlay'), scGameoverOverlay = document.getElementById('sc-gameover-overlay'), scStartBtn = document.getElementById('sc-start-btn'), scRestartBtn = document.getElementById('sc-restart-btn'), scScoreDisplay = document.getElementById('sc-score'), scFinalScore = document.getElementById('sc-final-score'), scSpeedInput = document.getElementById('sc-speed-input');
        const SC_CONFIG = { COLORS: ['#a8e05f', '#f3f313', '#33e3e4', '#c9333f'], SPEED_INCREMENT: 0.2, MOVE_STEP: 35 };
        let scPlayer, scBlockRow, scGameActive, scGamePaused, scScore, scSpeed, scGameLoopId;
        function createDrill() { const drill = document.createElement('div'); drill.className = 'sc-player-drill'; drill.innerHTML = `<svg viewBox="0 0 30 40" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15 0L0 25H30L15 0Z" stroke-width="3" stroke-linejoin="round"/><rect x="7" y="25" width="16" height="5" stroke-width="3" stroke-linejoin="round"/><rect x="7" y="32" width="16" height="5" stroke-width="3" stroke-linejoin="round"/></svg>`; scContainer.appendChild(drill); return drill; }
        function startSafeCrackGame() { scStartOverlay.classList.add('hidden'); scGameoverOverlay.classList.add('hidden'); scScore = 0; scSpeed = parseFloat(scSpeedInput.value); if (isNaN(scSpeed) || scSpeed <= 0) scSpeed = 2; scGameActive = true; scGamePaused = false; updateScoreDisplay(); startNewSCRound(); }
        function startNewSCRound() { if (!scGameActive) return; if (scBlockRow) scBlockRow.remove(); scBlockRow = document.createElement('div'); scBlockRow.className = 'sc-block-row'; scBlockRow.style.top = '-50px'; const shuffledColors = [...SC_CONFIG.COLORS].sort(() => Math.random() - 0.5); shuffledColors.forEach(color => { const seg = document.createElement('div'); seg.className = 'sc-block-segment'; seg.style.backgroundColor = color; scBlockRow.appendChild(seg); }); scContainer.appendChild(scBlockRow); const targetColorIndex = Math.floor(Math.random() * 4); scPlayer.querySelector('svg path, svg rect').style.stroke = shuffledColors[targetColorIndex]; scPlayer.dataset.targetColorIndex = targetColorIndex; cancelAnimationFrame(scGameLoopId); scGameLoopId = requestAnimationFrame(gameLoop); }
        function gameLoop() { if (!scGameActive) return; if (!scGamePaused) { const currentTop = parseFloat(scBlockRow.style.top); scBlockRow.style.top = `${currentTop + scSpeed}px`; if (currentTop + scBlockRow.offsetHeight >= scContainer.clientHeight - 10) { checkSCResult(); } } scGameLoopId = requestAnimationFrame(gameLoop); }
        function checkSCResult() { const playerRect = scPlayer.getBoundingClientRect(); const playerCenter = playerRect.left + playerRect.width / 2; const segments = scBlockRow.querySelectorAll('.sc-block-segment'); let correctHit = false; let hitSegment = null; segments.forEach((segment, index) => { const segmentRect = segment.getBoundingClientRect(); if(playerCenter >= segmentRect.left && playerCenter <= segmentRect.right && index == scPlayer.dataset.targetColorIndex) { correctHit = true; hitSegment = segment; } }); if (correctHit) { scGamePaused = true; scScore++; scSpeed += SC_CONFIG.SPEED_INCREMENT; updateScoreDisplay(); scPlayer.classList.add('hit-animation'); hitSegment.classList.add('breaking'); setTimeout(() => { scPlayer.classList.remove('hit-animation'); scGamePaused = false; startNewSCRound(); }, 500); } else { gameOverSC(); } }
        function gameOverSC() { scGameActive = false; cancelAnimationFrame(scGameLoopId); scFinalScore.textContent = `Pontos: ${scScore}`; scGameoverOverlay.classList.remove('hidden'); }
        function updateScoreDisplay() { scScoreDisplay.textContent = `Pontos: ${scScore}`; }
        function movePlayer(direction) { if(!scGameActive || scGamePaused) return; const playerWidth = scPlayer.clientWidth; const containerWidth = scContainer.clientWidth; let currentLeft = scPlayer.offsetLeft; let newLeft = (direction === 'left') ? currentLeft - SC_CONFIG.MOVE_STEP : currentLeft + SC_CONFIG.MOVE_STEP; newLeft = Math.max(0, Math.min(containerWidth - playerWidth, newLeft)); scPlayer.style.left = `${newLeft}px`; }
        function resetSafeCrackGame() { scGameActive = false; cancelAnimationFrame(scGameLoopId); scStartOverlay.classList.remove('hidden'); scGameoverOverlay.classList.add('hidden'); if (scBlockRow) scBlockRow.remove(); if (scPlayer) { const containerWidth = scContainer.clientWidth; const playerWidth = scPlayer.clientWidth; scPlayer.style.left = `${(containerWidth / 2) - (playerWidth / 2)}px`; } }
        scPlayer = createDrill();
        resetSafeCrackGame();
        scStartBtn.addEventListener('click', startSafeCrackGame);
        scRestartBtn.addEventListener('click', startSafeCrackGame);
        window.addEventListener('keydown', (e) => { if(document.getElementById('safe-crack-game').classList.contains('active')) { if (e.key === 'ArrowLeft') movePlayer('left'); else if (e.key === 'ArrowRight') movePlayer('right'); } });
    </script>

</body>
</html>